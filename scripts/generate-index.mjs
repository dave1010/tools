import { promises as fs } from 'fs';
import path from 'path';

const rootDir = process.cwd();
const toolsDir = path.join(rootDir, 'tools');
const templatePath = path.join(rootDir, 'src', 'index.template.html');

const entries = await fs.readdir(toolsDir, { withFileTypes: true });
const tools = [];

for (const entry of entries) {
  if (!entry.isDirectory()) continue;

  const slug = entry.name;
  const readmePath = path.join(toolsDir, slug, 'README.md');
  let content;

  try {
    content = await fs.readFile(readmePath, 'utf8');
  } catch (error) {
    throw new Error(`Missing README.md with front matter for tool: ${slug}`);
  }

  const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---\s*(?:\n|$)/);

  if (!frontMatterMatch) {
    throw new Error(`README.md for tool "${slug}" must contain YAML front matter.`);
  }

  const data = {};
  for (const line of frontMatterMatch[1].split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const separatorIndex = trimmed.indexOf(':');
    if (separatorIndex === -1) continue;
    const key = trimmed.slice(0, separatorIndex).trim();
    let value = trimmed.slice(separatorIndex + 1).trim();
    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    data[key] = value;
  }

  const title = data.title;
  const description = data.description;

  if (!title || !description) {
    throw new Error(`README.md for tool "${slug}" must define both title and description.`);
  }

  tools.push({ slug, title, description });
}

tools.sort((a, b) => a.title.localeCompare(b.title));

const escapeHtml = (value) =>
  value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

const listItems = tools
  .map(
    (tool) => `        <li>
          <a href="/tools/${tool.slug}" class="group relative flex h-full flex-col overflow-hidden rounded-2xl border border-fuchsia-500/30 bg-white/5 p-5 transition-all duration-200 hover:-translate-y-1 hover:border-cyan-400/60 hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-cyan-200">
            <div class="flex items-center justify-between gap-3">
              <span class="text-lg font-semibold text-white transition-colors duration-200 group-hover:text-cyan-200">${escapeHtml(tool.title)}</span>
              <span aria-hidden="true" class="rounded-full bg-fuchsia-500/20 p-2 text-fuchsia-200 transition-transform duration-200 group-hover:translate-x-1 group-hover:text-white">
                <svg class="size-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14m-7-7 7 7-7 7" />
                </svg>
              </span>
            </div>
            <p class="mt-3 text-sm text-white/70">${escapeHtml(tool.description)}</p>
          </a>
        </li>`
  )
  .join('\n');

const template = await fs.readFile(templatePath, 'utf8');

if (!template.includes('{{TOOLS_LIST}}')) {
  throw new Error(`Template ${templatePath} must include a {{TOOLS_LIST}} placeholder.`);
}

let html = template.replace('{{TOOLS_LIST}}', listItems);

if (template.includes('{{TOOLS_COUNT}}')) {
  html = html.replace(/{{TOOLS_COUNT}}/g, String(tools.length));
}

await fs.writeFile(path.join(rootDir, 'index.html'), html);

const readmePath = path.join(rootDir, 'README.md');
const readme = await fs.readFile(readmePath, 'utf8');
const startMarker = '<!-- TOOLS-LIST:START -->';
const endMarker = '<!-- TOOLS-LIST:END -->';

if (!readme.includes(startMarker) || !readme.includes(endMarker)) {
  throw new Error(
    `README.md must include ${startMarker} and ${endMarker} markers to update the tools list.`
  );
}

const readmeListItems = tools
  .map(
    (tool) =>
      `- [${tool.title}](https://tools.dave.engineer/tools/${tool.slug}) â€” ${tool.description}`
  )
  .join('\n');

const generatedNotice = '<!-- This section is automatically generated by `npm run build`. -->';
const readmeSection = `${startMarker}\n\n${generatedNotice}\n\n${readmeListItems}\n\n${endMarker}`;
const readmeSectionRegex = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`);
const updatedReadme = readme.replace(readmeSectionRegex, readmeSection).replace(/\s*$/, '\n');

await fs.writeFile(readmePath, updatedReadme);
