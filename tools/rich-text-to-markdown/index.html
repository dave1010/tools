<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rich Text to Markdown</title>
    <link rel="stylesheet" href="/assets/tw.css" />
    <style>
      body,
      html {
        height: 100%;
      }

      main {
        min-height: 100vh;
      }

      #pasteArea:empty::before {
        content: attr(data-placeholder);
        color: rgb(107 114 128);
      }

      #pasteArea:focus::before {
        content: '';
      }

      .editor-area {
        min-height: clamp(320px, 70vh, calc(100vh - 12rem));
      }
    </style>
  </head>
  <body class="bg-brand-50 text-gray-900">
    <main class="flex min-h-screen flex-col gap-6 p-4 font-sans md:p-6">
      <header>
        <h1 class="text-3xl font-semibold text-brand-700">Rich Text to Markdown</h1>
      </header>

      <section id="inputSection" class="flex flex-1 flex-col gap-3">
        <label id="pasteAreaLabel" class="block text-sm font-medium text-gray-700">Paste formatted content</label>
        <div
          id="pasteArea"
          class="editor-area w-full flex-1 resize-none rounded-lg border border-brand-200 bg-white p-3 shadow-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-100"
          contenteditable="true"
          role="textbox"
          aria-multiline="true"
          tabindex="0"
          aria-labelledby="pasteAreaLabel"
          data-placeholder="Tap or click here, then paste your rich text (⌘/Ctrl + V)."
        ></div>
      </section>

      <section id="resultWrapper" class="hidden flex flex-1 flex-col gap-3">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <label for="markdownOutput" class="block text-sm font-medium text-gray-700">Markdown output</label>
          <div class="flex flex-wrap items-center gap-2">
            <button id="backButton" type="button" class="btn btn-secondary">Back</button>
            <button id="scratchPadButton" type="button" class="btn btn-secondary">Open in Scratch Pad</button>
            <button id="copyButton" type="button" class="btn btn-primary">Copy Markdown</button>
          </div>
        </div>
        <textarea
          id="markdownOutput"
          class="editor-area w-full flex-1 resize-none rounded-lg border border-brand-200 bg-white p-3 font-mono text-sm shadow-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-100"
        ></textarea>
        <p id="statusMessage" class="text-sm text-gray-500"></p>
      </section>

      <section class="rounded-2xl border border-gray-200 bg-white p-4 shadow-soft md:p-6">
        <h2 class="text-lg font-semibold text-gray-900">Related tools</h2>
        <div class="mt-3 flex flex-wrap gap-3">
          <a class="btn" href="/tools/html-live-preview/">Live HTML Previewer</a>
          <a class="btn" href="/tools/markdown-to-html/">Markdown to HTML</a>
          <a class="btn" href="/tools/scratch-pad/">Scratch Pad</a>
        </div>
      </section>

      <footer class="py-6 text-center text-sm text-gray-500">
        <div class="flex justify-center gap-4">
          <a href="/" class="font-medium text-brand-700 hover:text-brand-600">← Back to tools.dave.engineer</a>
          <a href="https://github.com/dave1010/tools/tree/main/tools/rich-text-to-markdown" class="font-medium text-brand-700 hover:text-brand-600">About</a>
        </div>
      </footer>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/turndown@7.2.0/dist/turndown.js" onerror="alert('Failed to load: ' + this.src)"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown-plugin-gfm@1.0.2/dist/turndown-plugin-gfm.js" onerror="alert('Failed to load: ' + this.src)"></script>
    <script>
      const inputSection = document.getElementById('inputSection');
      const pasteAreaLabel = document.getElementById('pasteAreaLabel');
      const pasteArea = document.getElementById('pasteArea');
      const resultWrapper = document.getElementById('resultWrapper');
      const markdownOutput = document.getElementById('markdownOutput');
      const statusMessage = document.getElementById('statusMessage');
      const copyButton = document.getElementById('copyButton');
      const backButton = document.getElementById('backButton');
      const scratchPadButton = document.getElementById('scratchPadButton');

      const createTurndownInstance = () => {
        if (typeof TurndownService !== 'function') {
          return null;
        }

        const instance = new TurndownService({
          headingStyle: 'atx',
          codeBlockStyle: 'fenced',
        });

        if (window.turndownPluginGfm && turndownPluginGfm.gfm) {
          instance.use(turndownPluginGfm.gfm);
        }

        return instance;
      };

      const turndownService = createTurndownInstance();
      const cellTurndown = createTurndownInstance();

      const sanitizeCellContent = (value) => {
        if (!value) {
          return '';
        }

        return value
          .replace(/\u00a0/g, ' ')
          .replace(/\r?\n/g, '<br />')
          .replace(/\|/g, '\\|')
          .trim();
      };

      const extractAlignment = (cell) => {
        if (!cell || !cell.getAttribute) {
          return '---';
        }

        const alignAttribute = (cell.getAttribute('align') || '').toLowerCase();
        const styleAlign = (cell.style && cell.style.textAlign ? cell.style.textAlign : '').toLowerCase();
        const alignValue = alignAttribute || styleAlign;

        switch (alignValue) {
          case 'center':
            return ':---:';
          case 'right':
            return '---:';
          case 'left':
            return ':---';
          default:
            return '---';
        }
      };

      const normalizeRowLength = (values, length) => {
        const row = new Array(length).fill('');
        values.forEach((value, index) => {
          row[index] = value ?? '';
        });
        return row;
      };

      const convertCellToMarkdown = (cell) => {
        if (!cell) {
          return '';
        }

        if (cellTurndown) {
          try {
            const converted = cellTurndown.turndown(cell.innerHTML);
            return sanitizeCellContent(converted);
          } catch (error) {
            console.warn('Failed to convert table cell with Turndown', error);
          }
        }

        return sanitizeCellContent(cell.textContent || '');
      };

      const convertTableNodeToMarkdown = (tableNode) => {
        if (!tableNode || !tableNode.rows) {
          return '';
        }

        const allRows = Array.from(tableNode.rows);
        if (!allRows.length) {
          return '';
        }

        const headRows = tableNode.tHead ? Array.from(tableNode.tHead.rows) : [];
        const headRowSet = new Set(headRows);

        let headerCells = [];
        let dataRowElements = [];

        if (headRows.length) {
          headerCells = Array.from(headRows[0].cells);
          dataRowElements = allRows.filter((row) => !headRowSet.has(row));
        } else if (allRows.length) {
          const firstRowCells = Array.from(allRows[0].cells);
          const hasExplicitHeader = firstRowCells.some(
            (cell) => cell.tagName && cell.tagName.toLowerCase() === 'th'
          );

          if (hasExplicitHeader) {
            headerCells = firstRowCells;
            dataRowElements = allRows.slice(1);
          } else {
            headerCells = [];
            dataRowElements = allRows.slice();
          }
        }

        const bodyRowsMarkdown = dataRowElements.map((row) =>
          Array.from(row.cells).map(convertCellToMarkdown)
        );

        const inferredColumnCount = Math.max(
          headerCells.length,
          ...bodyRowsMarkdown.map((row) => row.length)
        );

        const columnCount = inferredColumnCount > 0 ? inferredColumnCount : headerCells.length || 0;

        if (!columnCount) {
          return '';
        }

        let headerValues = headerCells.length
          ? headerCells.map(convertCellToMarkdown)
          : bodyRowsMarkdown[0]
          ? bodyRowsMarkdown[0].map((value, index) => value || `Column ${index + 1}`)
          : Array.from({ length: columnCount }, (_, index) => `Column ${index + 1}`);

        headerValues = normalizeRowLength(headerValues, columnCount);

        const alignmentSources = headerCells.length
          ? headerCells
          : bodyRowsMarkdown.length && dataRowElements.length
          ? Array.from(dataRowElements[0].cells)
          : [];

        const alignmentRow = normalizeRowLength(
          alignmentSources.map(extractAlignment),
          columnCount
        );

        const bodyLines = bodyRowsMarkdown.length
          ? bodyRowsMarkdown.map((rowValues) => {
              const normalizedValues = normalizeRowLength(rowValues, columnCount);
              return `| ${normalizedValues.join(' | ')} |`;
            })
          : [`| ${new Array(columnCount).fill('').join(' | ')} |`];

        const headerLine = `| ${headerValues.join(' | ')} |`;
        const alignmentLine = `| ${alignmentRow
          .map((alignment) => (alignment && alignment.trim() ? alignment : '---'))
          .join(' | ')} |`;

        return `\n${[headerLine, alignmentLine, ...bodyLines].join('\n')}\n`;
      };

      if (turndownService) {
        turndownService.addRule('tablesToMarkdown', {
          filter: 'table',
          replacement: (_content, node) => convertTableNodeToMarkdown(node),
        });
      }

      const updateStatus = (message, type = 'info') => {
        statusMessage.textContent = message;
        statusMessage.className = `text-sm ${type === 'success' ? 'text-brand-600' : 'text-gray-500'}`;
      };

      const showResultView = () => {
        pasteAreaLabel.classList.add('hidden');
        pasteArea.classList.add('hidden');
        inputSection.classList.add('hidden');
        resultWrapper.classList.remove('hidden');
      };

      const resetView = () => {
        markdownOutput.value = '';
        resultWrapper.classList.add('hidden');
        inputSection.classList.remove('hidden');
        pasteAreaLabel.classList.remove('hidden');
        pasteArea.classList.remove('hidden');
        pasteArea.innerHTML = '';
        updateStatus('');
        try {
          pasteArea.focus({ preventScroll: true });
        } catch (error) {
          pasteArea.focus();
        }
      };

      const copyMarkdownToClipboard = async (value, { silent = false } = {}) => {
        if (!value) {
          return false;
        }

        try {
          await navigator.clipboard.writeText(value);
          if (!silent) {
            updateStatus('Markdown copied to clipboard.', 'success');
          }
          return true;
        } catch (error) {
          console.warn('Clipboard copy failed', error);
          markdownOutput.focus();
          markdownOutput.select();
          if (!silent) {
            updateStatus('Press ⌘/Ctrl + C to copy.', 'info');
          }
          return false;
        }
      };

      const convertClipboardData = async (event) => {
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }

        const clipboardData = event.clipboardData || window.clipboardData;

        if (!clipboardData) {
          updateStatus('Unable to access clipboard data in this browser.');
          return;
        }

        const htmlData = clipboardData.getData('text/html');
        const plainText = clipboardData.getData('text/plain');
        let markdownText = '';

        if (htmlData) {
          if (turndownService) {
            try {
              markdownText = turndownService.turndown(htmlData);
            } catch (error) {
              console.error('Turndown conversion failed', error);
              markdownText = plainText;
            }
          } else {
            markdownText = plainText;
            if (!markdownText) {
              updateStatus('The Markdown converter is unavailable. Try reloading the page.', 'info');
              return;
            }
          }
        } else if (plainText) {
          markdownText = plainText;
        }

        markdownText = markdownText.trim();

        if (!markdownText) {
          updateStatus('Nothing to convert from the clipboard.');
          resultWrapper.classList.add('hidden');
          markdownOutput.value = '';
          return;
        }

        markdownOutput.value = markdownText;
        showResultView();

        const copied = await copyMarkdownToClipboard(markdownText, { silent: true });
        updateStatus(
          copied ? 'Markdown ready and copied to clipboard.' : 'Markdown ready. Use Copy Markdown to copy.',
          copied ? 'success' : 'info'
        );
      };

      document.addEventListener('paste', convertClipboardData);

      copyButton.addEventListener('click', async () => {
        const value = markdownOutput.value;
        await copyMarkdownToClipboard(value);
      });

      backButton.addEventListener('click', () => {
        resetView();
      });

      scratchPadButton.addEventListener('click', () => {
        const value = markdownOutput.value || '';
        try {
          window.localStorage.setItem('scratch-pad-content', value);
        } catch (error) {
          console.warn('Unable to save scratch pad content', error);
        }
        window.location.href = '/tools/scratch-pad/';
      });

      window.addEventListener('load', () => {
        try {
          pasteArea.focus({ preventScroll: true });
        } catch (error) {
          pasteArea.focus();
        }
      });
    </script>
  </body>
</html>
