<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rich Text to Markdown</title>
    <link rel="stylesheet" href="/assets/tw.css" />
    <style>
      #pasteArea:empty::before {
        content: attr(data-placeholder);
        color: rgb(107 114 128);
      }

      #pasteArea:focus::before {
        content: '';
      }
    </style>
  </head>
  <body class="bg-brand-50 text-gray-900">
    <main class="mx-auto max-w-3xl p-4 md:p-6 space-y-4 font-sans">
      <header class="space-y-2">
        <h1 class="text-3xl font-semibold text-brand-700">Rich Text to Markdown</h1>
        <p class="text-gray-600">
          Focus the box below and paste any formatted content. The converted Markdown will appear instantly.
        </p>
      </header>

      <section class="space-y-3">
        <label id="pasteAreaLabel" class="block text-sm font-medium text-gray-700">Paste formatted content</label>
        <div
          id="pasteArea"
          class="w-full min-h-[180px] resize-vertical rounded-lg border border-brand-200 bg-white p-3 shadow-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-100"
          contenteditable="true"
          role="textbox"
          aria-multiline="true"
          tabindex="0"
          aria-labelledby="pasteAreaLabel"
          data-placeholder="Tap or click here, then paste your rich text (⌘/Ctrl + V)."
        ></div>
        <p class="text-sm text-gray-500">
          Tip: If your clipboard doesn&apos;t include formatting, the plain text will be used instead.
        </p>
      </section>

      <section id="resultWrapper" class="space-y-3 hidden">
        <div class="flex items-center justify-between gap-3">
          <label for="markdownOutput" class="block text-sm font-medium text-gray-700">Markdown output</label>
          <button id="copyButton" type="button" class="btn btn-primary">Copy Markdown</button>
        </div>
        <textarea
          id="markdownOutput"
          class="w-full min-h-[220px] resize-vertical rounded-lg border border-brand-200 bg-white p-3 font-mono text-sm shadow-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-100"
          readonly
        ></textarea>
        <p id="statusMessage" class="text-sm text-gray-500"></p>
      </section>

      <footer class="py-6 text-center text-sm text-gray-500">
        <div class="flex justify-center gap-4">
          <a href="/" class="font-medium text-brand-700 hover:text-brand-600">← Back to tools.dave.engineer</a>
          <a href="https://github.com/dave1010/tools/tree/main/tools/rich-text-to-markdown" class="font-medium text-brand-700 hover:text-brand-600">About</a>
        </div>
      </footer>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/turndown@7.2.0/dist/turndown.js" onerror="alert('Failed to load: ' + this.src)"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown-plugin-gfm@1.0.2/dist/turndown-plugin-gfm.js" onerror="alert('Failed to load: ' + this.src)"></script>
    <script>
      const pasteArea = document.getElementById('pasteArea');
      const resultWrapper = document.getElementById('resultWrapper');
      const markdownOutput = document.getElementById('markdownOutput');
      const statusMessage = document.getElementById('statusMessage');
      const copyButton = document.getElementById('copyButton');

      const createTurndownInstance = () => {
        if (typeof TurndownService !== 'function') {
          return null;
        }

        const instance = new TurndownService({
          headingStyle: 'atx',
          codeBlockStyle: 'fenced',
        });

        if (window.turndownPluginGfm && turndownPluginGfm.gfm) {
          instance.use(turndownPluginGfm.gfm);
        }

        return instance;
      };

      const turndownService = createTurndownInstance();
      const cellTurndown = createTurndownInstance();

      const sanitizeCellContent = (value) => {
        if (!value) {
          return '';
        }

        return value
          .replace(/\u00a0/g, ' ')
          .replace(/\r?\n/g, '<br />')
          .replace(/\|/g, '\\|')
          .trim();
      };

      const extractAlignment = (cell) => {
        if (!cell || !cell.getAttribute) {
          return '---';
        }

        const alignAttribute = (cell.getAttribute('align') || '').toLowerCase();
        const styleAlign = (cell.style && cell.style.textAlign ? cell.style.textAlign : '').toLowerCase();
        const alignValue = alignAttribute || styleAlign;

        switch (alignValue) {
          case 'center':
            return ':---:';
          case 'right':
            return '---:';
          case 'left':
            return ':---';
          default:
            return '---';
        }
      };

      const normalizeRowLength = (values, length) => {
        const row = new Array(length).fill('');
        values.forEach((value, index) => {
          row[index] = value ?? '';
        });
        return row;
      };

      const convertCellToMarkdown = (cell) => {
        if (!cell) {
          return '';
        }

        if (cellTurndown) {
          try {
            const converted = cellTurndown.turndown(cell.innerHTML);
            return sanitizeCellContent(converted);
          } catch (error) {
            console.warn('Failed to convert table cell with Turndown', error);
          }
        }

        return sanitizeCellContent(cell.textContent || '');
      };

      const convertTableNodeToMarkdown = (tableNode) => {
        if (!tableNode || !tableNode.rows) {
          return '';
        }

        const allRows = Array.from(tableNode.rows);
        if (!allRows.length) {
          return '';
        }

        const headRows = tableNode.tHead ? Array.from(tableNode.tHead.rows) : [];
        const headRowSet = new Set(headRows);

        let headerCells = [];
        let dataRowElements = [];

        if (headRows.length) {
          headerCells = Array.from(headRows[0].cells);
          dataRowElements = allRows.filter((row) => !headRowSet.has(row));
        } else if (allRows.length) {
          const firstRowCells = Array.from(allRows[0].cells);
          const hasExplicitHeader = firstRowCells.some(
            (cell) => cell.tagName && cell.tagName.toLowerCase() === 'th'
          );

          if (hasExplicitHeader) {
            headerCells = firstRowCells;
            dataRowElements = allRows.slice(1);
          } else {
            headerCells = [];
            dataRowElements = allRows.slice();
          }
        }

        const bodyRowsMarkdown = dataRowElements.map((row) =>
          Array.from(row.cells).map(convertCellToMarkdown)
        );

        const inferredColumnCount = Math.max(
          headerCells.length,
          ...bodyRowsMarkdown.map((row) => row.length)
        );

        const columnCount = inferredColumnCount > 0 ? inferredColumnCount : headerCells.length || 0;

        if (!columnCount) {
          return '';
        }

        let headerValues = headerCells.length
          ? headerCells.map(convertCellToMarkdown)
          : bodyRowsMarkdown[0]
          ? bodyRowsMarkdown[0].map((value, index) => value || `Column ${index + 1}`)
          : Array.from({ length: columnCount }, (_, index) => `Column ${index + 1}`);

        headerValues = normalizeRowLength(headerValues, columnCount);

        const alignmentSources = headerCells.length
          ? headerCells
          : bodyRowsMarkdown.length && dataRowElements.length
          ? Array.from(dataRowElements[0].cells)
          : [];

        const alignmentRow = normalizeRowLength(
          alignmentSources.map(extractAlignment),
          columnCount
        );

        const bodyLines = bodyRowsMarkdown.length
          ? bodyRowsMarkdown.map((rowValues) => {
              const normalizedValues = normalizeRowLength(rowValues, columnCount);
              return `| ${normalizedValues.join(' | ')} |`;
            })
          : [`| ${new Array(columnCount).fill('').join(' | ')} |`];

        const headerLine = `| ${headerValues.join(' | ')} |`;
        const alignmentLine = `| ${alignmentRow
          .map((alignment) => (alignment && alignment.trim() ? alignment : '---'))
          .join(' | ')} |`;

        return `\n${[headerLine, alignmentLine, ...bodyLines].join('\n')}\n`;
      };

      if (turndownService) {
        turndownService.addRule('tablesToMarkdown', {
          filter: 'table',
          replacement: (_content, node) => convertTableNodeToMarkdown(node),
        });
      }

      const updateStatus = (message, type = 'info') => {
        statusMessage.textContent = message;
        statusMessage.className = `text-sm ${type === 'success' ? 'text-brand-600' : 'text-gray-500'}`;
      };

      const convertClipboardData = (event) => {
        const clipboardData = event.clipboardData || window.clipboardData;

        if (!clipboardData) {
          updateStatus('Unable to access clipboard data in this browser.');
          return;
        }

        const htmlData = clipboardData.getData('text/html');
        const plainText = clipboardData.getData('text/plain');
        let markdownText = '';
        let sourceType = '';

        if (htmlData) {
          if (turndownService) {
            try {
              markdownText = turndownService.turndown(htmlData);
              sourceType = 'rich text';
            } catch (error) {
              console.error('Turndown conversion failed', error);
              markdownText = plainText;
              sourceType = 'plain text (fallback)';
            }
          } else {
            markdownText = plainText;
            sourceType = markdownText ? 'plain text (fallback)' : '';
            if (!markdownText) {
              updateStatus('The Markdown converter is unavailable. Try reloading the page.', 'info');
              return;
            }
          }
        } else if (plainText) {
          markdownText = plainText;
          sourceType = 'plain text';
        }

        markdownText = markdownText.trim();

        if (!markdownText) {
          updateStatus('Nothing to convert from the clipboard.');
          resultWrapper.classList.add('hidden');
          markdownOutput.value = '';
          return;
        }

        markdownOutput.value = markdownText;
        resultWrapper.classList.remove('hidden');
        const successMessage = sourceType
          ? `Converted from ${sourceType}.`
          : 'Converted clipboard contents.';
        updateStatus(successMessage, 'success');
      };

      pasteArea.addEventListener('paste', convertClipboardData);

      copyButton.addEventListener('click', async () => {
        const value = markdownOutput.value;
        try {
          await navigator.clipboard.writeText(value);
          updateStatus('Markdown copied to clipboard.', 'success');
        } catch (error) {
          console.warn('Clipboard copy failed', error);
          markdownOutput.removeAttribute('readonly');
          markdownOutput.focus();
          markdownOutput.select();
          markdownOutput.setAttribute('readonly', '');
          updateStatus('Press ⌘/Ctrl + C to copy.', 'info');
        }
      });

      window.addEventListener('load', () => {
        try {
          pasteArea.focus({ preventScroll: true });
        } catch (error) {
          pasteArea.focus();
        }
      });
    </script>
  </body>
</html>
