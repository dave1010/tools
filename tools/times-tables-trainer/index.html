<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Times Tables Trainer</title>
    <link rel="stylesheet" href="/assets/tw.css" />
  </head>
  <body class="bg-gradient-to-b from-brand-50/60 to-white">
    <main class="mx-auto flex min-h-screen max-w-3xl flex-col space-y-6 p-4 font-sans md:p-6">
      <header class="space-y-2 text-center">
        <h1 class="text-3xl font-semibold text-gray-900">Times Tables Trainer</h1>
        <p class="text-base text-gray-600">
          Answer multiplication cards at your own pace. Mark how easy a card felt to help the trainer
          space repetitions like an Anki deck.
        </p>
      </header>

      <section class="card mx-auto w-full max-w-xl space-y-4">
        <div class="rounded-2xl border border-brand-100 bg-white p-6 shadow-soft">
          <div class="space-y-6">
            <div id="problem" class="text-center text-4xl font-semibold text-gray-900"></div>
            <div id="choices" class="flex flex-col gap-3"></div>
            <div id="feedback" class="min-h-[3rem] text-center text-lg font-medium text-gray-800"></div>
            <div id="rating" class="flex flex-col items-center gap-2"></div>
          </div>
        </div>
        <div class="flex items-center justify-between text-sm text-gray-600">
          <button id="toggle-stats" type="button" class="font-medium text-brand-700 hover:text-brand-600">
            Show stats
          </button>
          <button id="reset-progress" type="button" class="font-medium text-brand-700 hover:text-brand-600">
            Reset progress
          </button>
        </div>
      </section>

      <section id="stats-panel" class="mx-auto hidden w-full max-w-3xl space-y-4">
        <div class="rounded-2xl border border-brand-100 bg-white p-6 shadow-soft">
          <div class="flex items-center justify-between">
            <h2 class="text-2xl font-semibold text-gray-900">Heatmap</h2>
            <p class="text-sm text-gray-500">Higher scores mean easier cards.</p>
          </div>
          <div id="heatmap" class="overflow-auto pt-4"></div>
        </div>
      </section>

      <footer class="py-6 text-center text-sm text-gray-500">
        <div class="flex flex-col items-center justify-center gap-2 sm:flex-row sm:gap-4">
          <a href="/" class="font-medium text-brand-700 hover:text-brand-600">&larr; Back to tools.dave.engineer</a>
          <a href="https://github.com/dave1010/tools/tree/main/tools/times-tables-trainer" class="font-medium text-brand-700 hover:text-brand-600">About</a>
        </div>
      </footer>
    </main>

    <script type="module">
      const STORAGE_KEY = "times-tables-trainer-state-v1";
      const range = 12;
      const ratingScale = [
        { label: "Hard 🤔", value: 3 },
        { label: "OK 🙂", value: 4 },
        { label: "Easy 🤩", value: 5 },
      ];

      const problemEl = document.getElementById("problem");
      const choicesEl = document.getElementById("choices");
      const feedbackEl = document.getElementById("feedback");
      const ratingEl = document.getElementById("rating");
      const statsPanel = document.getElementById("stats-panel");
      const toggleStatsButton = document.getElementById("toggle-stats");
      const resetProgressButton = document.getElementById("reset-progress");
      const heatmapContainer = document.getElementById("heatmap");

      const numberEmojiMap = {
        "0": "🐿️",
        "1": "🌳",
        "2": "🍄",
        "3": "🍁",
        "4": "🌻",
        "5": "🐁",
        "6": "🐌",
        "7": "🐸",
        "8": "🌊",
        "9": "🌙",
      };

      let cards = [];
      let reviewCounter = 0;
      let currentCard = null;

      function numberToEmoji(number) {
        return number
          .toString()
          .split("")
          .map((digit) => numberEmojiMap[digit] ?? "")
          .join("");
      }

      function calculateEasiness(currentEasiness, rating) {
        const easinessUpdate = 0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02);
        return Math.max(1.3, currentEasiness + easinessUpdate);
      }

      function generateCards(max) {
        const nowDue = 0;
        const generated = [];
        for (let x = 1; x <= max; x += 1) {
          for (let y = 1; y <= max; y += 1) {
            generated.push({
              x,
              y,
              product: x * y,
              easiness: 2.5,
              interval: 1,
              due: nowDue,
            });
          }
        }
        return generated;
      }

      function normalizeCard(card) {
        return {
          x: Number(card.x) || 0,
          y: Number(card.y) || 0,
          product: Number(card.product) || Number(card.x) * Number(card.y),
          easiness: Number.isFinite(card.easiness) ? card.easiness : 2.5,
          interval: Number.isFinite(card.interval) && card.interval > 0 ? Math.round(card.interval) : 1,
          due: Number.isFinite(card.due) ? Math.round(card.due) : 0,
        };
      }

      function loadState() {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) {
          return { cards: generateCards(range), reviewCounter: 0 };
        }
        try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
            return { cards: parsed.map((item) => normalizeCard(item)), reviewCounter: 0 };
          }
          if (parsed && Array.isArray(parsed.cards)) {
            return {
              cards: parsed.cards.map((item) => normalizeCard(item)),
              reviewCounter: Number.isFinite(parsed.reviewCounter) ? Math.max(0, Math.round(parsed.reviewCounter)) : 0,
            };
          }
        } catch (error) {
          console.error("Failed to parse stored state", error);
        }
        return { cards: generateCards(range), reviewCounter: 0 };
      }

      function saveState() {
        localStorage.setItem(
          STORAGE_KEY,
          JSON.stringify({
            cards,
            reviewCounter,
          })
        );
      }

      function sortCards() {
        cards.sort((a, b) => {
          if (a.due === b.due) {
            if (a.easiness === b.easiness) {
              return Math.random() - 0.5;
            }
            return a.easiness - b.easiness;
          }
          return a.due - b.due;
        });
      }

      function shuffle(array) {
        const copy = [...array];
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      }

      function buildChoices(answer, count) {
        const values = new Set([answer]);
        while (values.size < count) {
          const candidate = (Math.floor(Math.random() * range) + 1) * (Math.floor(Math.random() * range) + 1);
          values.add(candidate);
        }
        const shuffledNumbers = shuffle([...values]);
        return [...shuffledNumbers, "not-sure"];
      }

      function createButton(label, onClick, variant = "primary") {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = label;
        button.className = `btn ${variant === "secondary" ? "btn-secondary" : "btn-primary"} w-full`;
        button.addEventListener("click", onClick);
        return button;
      }

      function disableButtons(container) {
        container.querySelectorAll("button").forEach((button) => {
          button.disabled = true;
        });
      }

      function syncComplement(card) {
        const complement = cards.find((candidate) => candidate !== card && candidate.x === card.y && candidate.y === card.x);
        if (!complement) {
          return;
        }
        complement.easiness = card.easiness;
        complement.interval = card.interval;
        complement.due = card.due;
      }

      function scheduleCard(card, rating) {
        card.easiness = calculateEasiness(card.easiness, rating);
        if (rating <= 2) {
          card.interval = 1;
        } else if (card.interval <= 1) {
          card.interval = rating === 3 ? 2 : 4;
        } else {
          const scaled = Math.round(card.interval * card.easiness);
          card.interval = Math.max(card.interval + 1, scaled);
        }
        card.due = reviewCounter + card.interval;
        syncComplement(card);
      }

      function renderHeatmap() {
        heatmapContainer.innerHTML = "";
        const table = document.createElement("table");
        table.className = "w-full border-separate border-spacing-1 text-sm";

        const headerRow = document.createElement("tr");
        const cornerCell = document.createElement("th");
        cornerCell.className = "p-1 text-center font-semibold text-gray-600";
        cornerCell.textContent = "×";
        headerRow.appendChild(cornerCell);
        for (let i = 1; i <= range; i += 1) {
          const th = document.createElement("th");
          th.className = "p-1 text-center font-semibold text-gray-600";
          th.textContent = i;
          headerRow.appendChild(th);
        }
        table.appendChild(headerRow);

        for (let y = 1; y <= range; y += 1) {
          const row = document.createElement("tr");
          const header = document.createElement("th");
          header.className = "p-1 text-center font-semibold text-gray-600";
          header.textContent = y;
          row.appendChild(header);

          for (let x = 1; x <= range; x += 1) {
            const cell = document.createElement("td");
            cell.className = "rounded-md p-2 text-center text-xs font-semibold text-gray-900";
            const entry = cards.find((candidate) => candidate.x === x && candidate.y === y);
            const easiness = entry ? entry.easiness : 0;
            cell.textContent = easiness.toFixed(1);
            const hue = easinessToHue(easiness);
            cell.style.backgroundColor = `hsl(${hue} 90% 75%)`;
            row.appendChild(cell);
          }
          table.appendChild(row);
        }

        heatmapContainer.appendChild(table);
      }

      function easinessToHue(easiness) {
        const clamped = Math.min(Math.max(easiness, 1.5), 3.2);
        const normalized = (clamped - 1.5) / (3.2 - 1.5);
        return Math.round(normalized * 120);
      }

      function showCard(card) {
        currentCard = card;
        problemEl.textContent = `${card.x} × ${card.y} = ?`;
        choicesEl.innerHTML = "";
        ratingEl.innerHTML = "";
        feedbackEl.textContent = "";

        const options = buildChoices(card.product, 4);
        options.forEach((choice) => {
          const buttonLabel = choice === "not-sure" ? "Not sure" : `${choice} ${numberToEmoji(choice)}`;
          const button = createButton(buttonLabel, () => handleChoice(choice), choice === "not-sure" ? "secondary" : "primary");
          choicesEl.appendChild(button);
        });
      }

      function getNextCard() {
        sortCards();
        const dueNow = cards.find((card) => card.due <= reviewCounter);
        return dueNow ?? cards[0];
      }

      function moveToNextCard() {
        reviewCounter += 1;
        saveState();
        renderHeatmap();
        const next = getNextCard();
        showCard(next);
      }

      function handleChoice(choice) {
        disableButtons(choicesEl);
        if (!currentCard) {
          return;
        }

        if (choice === currentCard.product) {
          feedbackEl.innerHTML = `✅ Correct! ${currentCard.product} ${numberToEmoji(currentCard.product)}<br />How easy was that?`;
          ratingEl.innerHTML = "";
          ratingScale.forEach(({ label, value }) => {
            const button = createButton(label, () => {
              disableButtons(ratingEl);
              scheduleCard(currentCard, value);
              moveToNextCard();
            });
            ratingEl.appendChild(button);
          });
          return;
        }

        const ratingValue = choice === "not-sure" ? 2 : 1;
        if (ratingValue === 2) {
          feedbackEl.textContent = `The answer is ${currentCard.product} ${numberToEmoji(currentCard.product)}.`;
        } else {
          feedbackEl.textContent = `Almost! The answer is ${currentCard.product} ${numberToEmoji(currentCard.product)}.`;
        }
        ratingEl.innerHTML = "";
        scheduleCard(currentCard, ratingValue);
        const nextButton = createButton("Next card", () => {
          disableButtons(ratingEl);
          moveToNextCard();
        });
        ratingEl.appendChild(nextButton);
      }

      function resetProgress() {
        if (!confirm("Reset all saved progress?")) {
          return;
        }
        localStorage.removeItem(STORAGE_KEY);
        const fresh = loadState();
        cards = fresh.cards;
        reviewCounter = fresh.reviewCounter;
        saveState();
        renderHeatmap();
        showCard(getNextCard());
      }

      toggleStatsButton.addEventListener("click", () => {
        const isHidden = statsPanel.classList.toggle("hidden");
        toggleStatsButton.textContent = isHidden ? "Show stats" : "Hide stats";
      });

      resetProgressButton.addEventListener("click", resetProgress);

      const initialState = loadState();
      cards = initialState.cards;
      reviewCounter = initialState.reviewCounter ?? 0;
      if (!Number.isFinite(reviewCounter)) {
        reviewCounter = 0;
      }
      sortCards();
      saveState();
      renderHeatmap();
      showCard(getNextCard());
    </script>
  </body>
</html>
